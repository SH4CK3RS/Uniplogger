//
//  PloggingWorker.swift
//  UniPlogger
//
//  Created by 손병근 on 2020/09/27.
//  Copyright (c) 2020 손병근. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import CoreLocation

protocol PloggingWorkerDelegate{
    func updateRoute(distance: Measurement<UnitLength>, location: Location)
}

class PloggingWorker: NSObject {
    let storage = Storage()
    
    static var trashCanList: [TrashCan] = [
        .init(latitude: 37.4972632, longitude: 126.8450178),
        .init(latitude: 37.5015682, longitude: 126.844351),
        .init(latitude: 37.4944, longitude: 126.8423623),
        .init(latitude: 37.4961687, longitude: 126.8426605)
    ]
    
    private let locationManager = CLLocationManager()
    private var distance = Measurement(value: 0, unit: UnitLength.kilometers)
    var locationList: [CLLocation] = []
    var delegate: PloggingWorkerDelegate?
    var updateAuthorization: ((CLAuthorizationStatus) -> Void)?
    override init() {
        super.init()
        locationManager.delegate = self
        locationManager.startUpdatingLocation()
    }
    
    //MARK: - Helper
    func requestPermission(){
        locationManager.requestWhenInUseAuthorization()
    }
    
    func resetLocationData(){
        distance = Measurement(value: 0, unit: UnitLength.meters)
    }
    func startRun(){
        resetLocationData()
        startUpdateLocation()
    }
    
    func pauseRun(){
        locationManager.stopUpdatingLocation()
    }
    
    func resumeRun(){
        startUpdateLocation()
        
    }
    
    func stopRun(completion: @escaping (Measurement<UnitLength>) -> Void){
        locationManager.stopUpdatingLocation()
        completion(distance)
    }
    
    func startUpdateLocation(){
        locationManager.delegate = self
        locationManager.activityType = .fitness
        locationManager.distanceFilter = 5
        locationManager.allowsBackgroundLocationUpdates = true
        locationManager.startUpdatingLocation()
    }
}

//MARK: - API
extension PloggingWorker{
    func getTrashCanList(completion: @escaping ([TrashCan]) -> Void){
        PloggingAPI.shared.fetchTrashList { (response) in
            switch response{
            case .success(let value):
                if value.success, let trashcanList = value.data{
                    self.fetchTrashCan { list in
                        if list.isEmpty{
                            // Toto add list
                            self.addTrashCanList(list: trashcanList, completion: completion)
                        }else{
                            var createList: [TrashCan] = []
                            trashcanList.forEach { item in
                                if (list.filter { $0.latitude != item.latitude && $0.longitude == item.longitude}.count == 0){
                                    createList.append(item)
                                }
                            }
                            self.addTrashCanList(list: createList){ _ in
                                createList.append(contentsOf: createList)
                                completion(createList)
                            }
                        }
                        
                    }
                } else {
                    
                }
                
            case .failure(let error):
                let error = Common.CommonError.error(error)
                completion([])
            }
        }
    }
}

//MARK: - TrashCan CRUD
extension PloggingWorker{
    
    func fetchTrashCan(completion: @escaping ([TrashCan]) -> Void){
        storage.fetchTrashCanList { (result) in
            switch result{
            case .success(let list):
                completion(list)
            case .failure(let error):
                print(error.localizedDescription)
            }
        }
    }
    func addTrashCanList(list: [TrashCan], completion: @escaping ([TrashCan]) -> Void){
        storage.createTrashCanList(list) { (result) in
            switch result{
            case .success(let lis):
                completion(lis)
            case .failure(let error):
                print(error.localizedDescription)
                completion([])
            }
        }
    }
    func addTrashCan(request: Plogging.AddConfirmTrashCan.Request, completion: @escaping (Plogging.AddConfirmTrashCan.Response) -> Void){
        PloggingAPI.shared.createTrashCan(
            latitude: request.latitude,
            longitude: request.longitude,
            address: request.address) { (response) in
            switch response{
            case let .success(value):
                if value.success, let trashcan = value.data{
                    self.storage.createTrashCan(trashcan) { (result) in
                        switch result{
                        case .success(let trashcan):
                            let response = Plogging.AddConfirmTrashCan.Response(request: request, response: trashcan)
                            completion(response)
                        case .failure(let error):
                            let response = Plogging.AddConfirmTrashCan.Response(request: request, error: .error(error))
                            completion(response)
                        }
                    }
                } else {
                    let response = Plogging.AddConfirmTrashCan.Response(request: request, error: .server(value.message))
                    completion(response)
                }
            case let .failure(error):
                let response = Plogging.AddConfirmTrashCan.Response(request: request, error: .error(error))
                completion(response)
            }
        }
        
    }
    
    func addTrashCan(trashCan: TrashCan, completion: @escaping (TrashCan) -> Void){
        storage.createTrashCan(trashCan) { (result) in
            switch result{
            case .success(let trashCan):
                completion(trashCan)
            case .failure(let error):
                print(error.localizedDescription)
            }
        }
    }
    
    func deleteTrashCan(request: Plogging.RemoveTrashCan.Request, completion: @escaping (Plogging.RemoveTrashCan.Response) -> Void){
        PloggingAPI.shared.deleteTrashCan(id: request.id) { (response) in
            switch response {
            case let .success(value):
                if value.success, let trashcan = value.data {
                    self.storage.deleteTrashCan(latitude: trashcan.latitude, longitude: trashcan.longitude) { (result) in
                        switch result{
                        case .success():
                            let response = Plogging.RemoveTrashCan.Response(request: request, trashcan: trashcan)
                            completion(response)
                        case .failure(let error):
                            let response = Plogging.RemoveTrashCan.Response(request: request, error: .error(error))
                            completion(response)
                        }
                    }
                } else {
                    let response = Plogging.RemoveTrashCan.Response(request: request, error: .server(value.message))
                    completion(response)
                }
            case let .failure(error):
                let response = Plogging.RemoveTrashCan.Response(request: request, error: .error(error))
                completion(response)
            }
        }
        
    }
}

extension PloggingWorker: CLLocationManagerDelegate{
    
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        if let newLocation = locations.last{
            UserDefaults.standard.set(newLocation.coordinate.asDictionary, forDefines: .location)
            let howRecent = newLocation.timestamp.timeIntervalSinceNow
            
            guard abs(howRecent) < 10 else { return }
            if let lastLocation = self.locationList.last {
                let delta = newLocation.distance(from: lastLocation)
                distance = distance + Measurement(value: delta, unit: UnitLength.meters)
                let location = Location(
                    latitude: newLocation.coordinate.latitude,
                    longitude: newLocation.coordinate.longitude,
                    timestamp: newLocation.timestamp)
                
                self.delegate?.updateRoute(distance: distance, location: location)
            }
            locationList.append(newLocation)
        }
    }
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        self.updateAuthorization?(status)
    }
}
