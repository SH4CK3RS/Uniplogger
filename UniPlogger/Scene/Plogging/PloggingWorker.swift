//
//  PloggingWorker.swift
//  UniPlogger
//
//  Created by 손병근 on 2020/09/27.
//  Copyright (c) 2020 손병근. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import CoreLocation

protocol PloggingWorkerDelegate {
    func updateRoute(distance: Measurement<UnitLength>, location: Location)
}

final class PloggingWorker: NSObject {
    let storage = Storage()
    
    private let locationManager = CLLocationManager()
    private var distance = Measurement(value: 0, unit: UnitLength.kilometers)
    var locationList: [CLLocation] = []
    var delegate: PloggingWorkerDelegate?
    var updateAuthorization: ((CLAuthorizationStatus) -> Void)?
    override init() {
        super.init()
        locationManager.delegate = self
        locationManager.startUpdatingLocation()
    }
    
    //MARK: - Helper
    func requestPermission() {
        locationManager.requestWhenInUseAuthorization()
    }
    
    func resetLocationData() {
        distance = Measurement(value: 0, unit: UnitLength.meters)
    }
    func startRun() {
        resetLocationData()
        startUpdateLocation()
    }
    
    func pauseRun() {
        locationManager.stopUpdatingLocation()
    }
    
    func resumeRun() {
        startUpdateLocation()
        
    }
    
    func stopRun(completion: @escaping (Measurement<UnitLength>) -> Void) {
        locationManager.stopUpdatingLocation()
        completion(distance)
    }
    
    func startUpdateLocation() {
        locationManager.delegate = self
        locationManager.activityType = .fitness
        locationManager.distanceFilter = 5
        locationManager.allowsBackgroundLocationUpdates = true
        locationManager.startUpdatingLocation()
    }
}

//MARK: - API
extension PloggingWorker{
    func getTrashCanList(completion: @escaping (Plogging.FetchTrashCan.Response) -> Void) {
        PloggingAPI.shared.fetchTrashList { (response) in
            switch response {
            case .success(let value):
                if value.status == .success, let trashcanList = value.data{
                    
                } else {
                    let response = Plogging.FetchTrashCan.Response(error: .networkError(.responseError(value.errorMessage ?? "")))
                    completion(response)
                }
                
            case .failure(let error):
                let response = Plogging.FetchTrashCan.Response(error: UniPloggerError.networkError(.responseError(error.localizedDescription)))
                completion(response)
            }
        }
    }
}

//MARK: - TrashCan CRUD
extension PloggingWorker{
    func addTrashCan(request: Plogging.AddConfirmTrashCan.Request, completion: @escaping (Plogging.AddConfirmTrashCan.Response) -> Void) {
        PloggingAPI.shared.createTrashCan(
            latitude: request.latitude,
            longitude: request.longitude,
            address: request.address) { (response) in
            switch response {
            case let .success(value):
                if value.status == .success, let trashcan = value.data{

                } else {
                    let response = Plogging.AddConfirmTrashCan.Response(request: request, error: .networkError(.responseError(value.errorMessage ?? "")))
                    completion(response)
                }
            case let .failure(error):
                let response = Plogging.AddConfirmTrashCan.Response(request: request, error: UniPloggerError.networkError(.responseError(error.localizedDescription)))
                completion(response)
            }
        }
        
    }
    
    func deleteTrashCan(request: Plogging.RemoveTrashCan.Request, completion: @escaping (Plogging.RemoveTrashCan.Response) -> Void) {
        PloggingAPI.shared.deleteTrashCan(id: request.id) { (response) in
            switch response {
            case let .success(value):
                if value.status == .success, let trashcan = value.data {
                    
                } else {
                    let response = Plogging.RemoveTrashCan.Response(request: request, error: .networkError(.responseError(value.errorMessage ?? "")))
                    completion(response)
                }
            case let .failure(error):
                let response = Plogging.RemoveTrashCan.Response(request: request, error: UniPloggerError.networkError(.responseError(error.localizedDescription)))
                completion(response)
            }
        }
        
    }
}

extension PloggingWorker: CLLocationManagerDelegate {
    
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        if let newLocation = locations.last{
            UserDefaults.standard.set(newLocation.coordinate.asDictionary, forDefines: .location)
            let howRecent = newLocation.timestamp.timeIntervalSinceNow
            
            guard abs(howRecent) < 10 else { return }
            if let lastLocation = self.locationList.last {
                let delta = newLocation.distance(from: lastLocation)
                distance = distance + Measurement(value: delta, unit: UnitLength.meters)
                let location = Location(
                    latitude: newLocation.coordinate.latitude,
                    longitude: newLocation.coordinate.longitude,
                    timestamp: newLocation.timestamp)
                
                self.delegate?.updateRoute(distance: distance, location: location)
            }
            locationList.append(newLocation)
        }
    }
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        self.updateAuthorization?(status)
    }
}
